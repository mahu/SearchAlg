\documentclass[11pt]{article}

\usepackage{microtype}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{enumitem}


\setlength{\parindent}{0cm}
\renewcommand\thesubsection{\alph{subsection})}

\title{\textbf{Assignment 3\\}Search Algorithms}
\author{Malik Al-hallak 90020\\
		Sebastian Utzig 100059\\
		Clemens Wegener 91268}
\date{}
\begin{document}

\maketitle
\section{Search in a graph}
\subsection{Depth-First Search}
\begin{tabular}{ c | l | l }
  Iteration & OPEN & CLOSE \\
  0 	&	0				&	$\emptyset$ \\
  1		&	13,15			&	0\\
  2		&	1,3,14,15		&	0,13\\
  3		&	2,3,14,15		&	0,13,1\\
  4		&	3,14,15			&	0,13,1,2\\
  5		&	4,8,14,15		&	0,13,1,2,3\\
  6		&	5,8,14,15		&	0,13,1,2,3,4\\
  7		&	6,8,14,15		&	0,13,1,2,3,4,5\\
  8		&	7,8,14,15		&	0,13,1,2,3,4,5,6\\
  9		&	8,14,15			&	0,13,1,2,3,4,5,6,7\\
  10	&	9,14,15			&	0,13,1,2,3,4,5,6,7,8\\
  11	&	10,12,14,15		&	0,13,1,2,3,4,5,6,7,8,9\\
  12	&	11,12,14,15		&	0,13,1,2,3,4,5,6,7,8,9,10\\
  13	&	12,14,15,16		&	0,13,1,2,3,4,5,6,7,8,9,10,11\\
  14	&	14,15,16		&	0,13,1,2,3,4,5,6,7,8,9,10,11,12\\
  15	&	15,16			&	0,13,1,2,3,4,5,6,7,8,9,10,11,12,14\\
  16	&	16				&	0,13,1,2,3,4,5,6,7,8,9,10,11,12,14,15\\
  17	&	$\emptyset$		&	0,13,1,2,3,4,5,6,7,8,9,10,11,12,14,15,16
 \end{tabular}
\subsection{Breadth-First Search}
\begin{tabular}{ c | l | l }
  Iteration & OPEN & CLOSE \\
  0 	&	0 				& $\emptyset$ \\
  1		&	13,15			&	0	\\
  2		&	15,1,3,14		&	0,13	\\
  3		&	1,3,14,12,16	&	0,13,15	\\
  4		&	3,14,12,16,2	&	0,13,15,1	\\
  5		&	14,12,16,2,4,8	&	0,13,15,1,3	\\
  6		&	12,16,2,4,8		&	0,13,15,1,3,14	\\
  7		&	16,2,4,8,9,11	&	0,13,15,1,3,14,12	\\
  8		&	2,4,8,9,11		&	0,13,15,1,3,14,12,16	\\
  9		&	4,8,9,11		&	0,13,15,1,3,14,12,16,2	\\
  10	&	8,9,11,5		&	0,13,15,1,3,14,12,16,2,4	\\
  11	&	9,11,5,6,7		&	0,13,15,1,3,14,12,16,2,4,8	\\
  12	&	11,5,6,7,10		&	0,13,15,1,3,14,12,16,2,4,8,9	\\
  13	&	5,6,7,10			&	0,13,15,1,3,14,12,16,2,4,8,9,11	\\
  14	&	6,7,10			&	0,13,15,1,3,14,12,16,2,4,8,9,11,5	\\
  15	&	7,10			&	0,13,15,1,3,14,12,16,2,4,8,9,11,5,6	\\
  16	&	10				&	0,13,15,1,3,14,12,16,2,4,8,9,11,5,6,7	\\
  17	&$\emptyset$		&	0,13,15,1,3,14,12,16,2,4,8,9,11,5,6,7,10	\\
 \end{tabular}

\subsection{Uniform Cost Search}

\emph{No node-repetition in CLOSE-list\\}
\begin{tabular}{ c | l | l }
  Iteration & OPEN & CLOSE \\
  0 	&	0 										& 	$\emptyset$ \\
  1		&	13(3),15(11)							&	0			\\
  2		&	1(5),14(11),15(11),3(24)				&	13(3)		\\
  3		&	2(9),14(11),15(11),3(24)				&	1(5)		\\
  4		&	14(11),15(11),3(18)						&	2(9)		\\
  5		&	15(11),3(18),12(21),8(29)				&	14(11)		\\
  6		&	16(12),3(18),12(18),8(29)				&	15(11)		\\
  7		&	3(18),12(18),11(28),8(29)				&	16(12)		\\
  8		&	12(18),11(28),8(29),4(31)				&	3(18)		\\
  9		&	11(23),8(29),4(31),9(33)				&	12(18)		\\
  10	&	8(29),4(31),9(33),10(40)				&	11(23)		\\
  11	&	4(31),9(33),5(35),10(40),7(42),6(53)	&	8(29)		\\
  12	&	9(33),5(35),10(40),7(42),6(53)			&	4(31)		\\
  13	&	5(35),10(40),7(42),6(53)				&	9(33)		\\
  14	&	10(40),7(42),6(53)						&	5(35)		\\
  15	&	7(42),6(53)								&	10(40)		\\
  16	&	6(53)									&	7(42)		\\
  17	&	$\emptyset$								&	6(53)
 \end{tabular}
\section{Uniform cost search}
If all weights in a graph are $1$ then uniform cost search behaves like breadth-first search. This is due to the fact that the longer the path from one node to the start node is, the bigger is the weight associated weight and hence, the later this node will be considered. This is the same with breadth first search.

\setcounter{section}{4}
\section{Special cost functions}
\subsection{}
No, please have a look at b) and c).

\subsection{}
$P(0)= 6\rightarrow 7\rightarrow 8\rightarrow 14\rightarrow 12\rightarrow 15 \rightarrow 0$\\
$f(0) = |19-7| = 12$

\subsection{}
No because the subpath $P_1(14)=6\rightarrow 7 \rightarrow 8 \rightarrow 14$ costs $7$ whereas $P_2(14)= 6 \rightarrow 8 \rightarrow 14$ has costs of $6$.

\section{Recursive cost functions}
\begin{enumerate}
	\item Shared computation:\\
	\indent Already computed evaluation results for a solution base $G$ are exploited for other solution bases that contain $G$
	\item Selective updating:\\
	\indent Only the predecessors of a newly explored node need to be updated.
\end{enumerate}
\section{State space search}
\subsection{}
Since the packaging problem is not decomposable an OR-graph is the suitable representation. We cannot determine any independent subproblem.

\subsection{}
The nodes represent already packaged weights and the remaining weights to pack. The edges indicate if a weight is inserted into a new created package ($1$) or into an already existing one ($0$).

\subsection{}
The list of remaining weights to pack is empty and the sum of weights for each package is $\leq 20$kg. Due to this condition all reached leaf nodes are solutions and dead ends are avoided.

\subsection{}
The cost equals to the sum of the already created packages times the cost per package. Each edge has either a cost of $0$ (no new package created) or $1$ ( a new package was created). The cost of a state is then determined by accumulating the costs associated with the edges on the path.

\subsection{}
We can calculate a lower bound $B$ by adding the already accumulated cost $C$ to an optimistic rest cost:

\begin{align*}
	B=C + \frac{\displaystyle{\sum_{w\in Weights}w}}{max\_weight\_per\_package}
\end{align*}

\subsection{}
Pleas find the code in the attached file \texttt{packing.py}

\subsection{}
\textbf{Output:}\\
\texttt{Solution found:\\ 
---------------\\
------State------\\
Weights: []\\
Packages: [[16], [15], [13, 7], [11, 9], [7, 6, 4, 1]]\\
Accumulated cost with last insertion: 5 package(s)\\
-----------------\\
}


\end{document}
